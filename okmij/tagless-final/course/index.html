<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  "http://www.w3.org/TR/REC-html40/loose.dtd">
<html lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <style type="text/css">
  <!--
  pre {margin-left:2em;}
  -->
  </style>
  <title>型付きタグレスファイナル解釈：講義録</title>
<body bgcolor="#FFFFFF"><div align="center"><a href="../index.html">previous</a>  &nbsp; <a href="Boehm-Berarducci.html">next</a>  &nbsp; <a href="../index.html">up</a>  &nbsp; <a href="http://kinokkory.github.io/okmij/">top</a><hr></div>
<div align="center"><h1>型付きタグレスファイナル解釈：講義録</h1>
</div>
<p>&nbsp;</p>
<p>The course on typed tagless-final embeddings of domain-specific languages has been presented at the Spring School on Generic and Indexed Programming (SSGIP) <a href="http://www.comlab.ox.ac.uk/projects/gip/school.html">&lt; http://www.comlab.ox.ac.uk/projects/gip/school.html &gt;</a> at Wadham College, Oxford, UK on 22nd to 26th March 2010. This page collects the notes for the course in the form of the extensively commented Haskell and OCaml code.</p>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#lecture">Lecture Notes</a>
<br>
&nbsp;</li>
<li><a href="#infin1">Initial and final, deep and shallow: the first-order case</a></li>
<li><a href="#fin-OCaml">Final embeddings in OCaml</a></li>
<li><a href="#non'compositionality">Non-compositionality: Fold-<em>unlike</em> processing</a></li>
<li><a href="Boehm-Berarducci.html">Boehm-Berarducci Encoding</a>
<br>
&nbsp;</li>
<li><a href="#HO">Type-preserving embedding of higher-order, typed DSLs</a></li>
<li><a href="#type-checking">De-serialization and type-checking</a>
<br>
&nbsp;</li>
<li><a href="#CPS">Ordinary and one-pass CPS transformation</a></li>
<li><a href="#TDPE">Type-directed partial evaluation</a></li>
<li><a href="#linear">Linear and affine lambda-calculi</a></li>
<li><a href="#misc">Further applications</a>
<br>
&nbsp;</li></ul>
<hr>
<p><a name="introduction">&nbsp;</a></p><h2>Introduction</h2>
<dl><dd>The topic of the course is the embedding of domain-specific languages (DSL) in a host language such as Haskell or OCaml. We will often call the language to embed `the object language' and the host language `the metalanguage'. All throughout the course we will repeatedly encounter the following points:<dl><dt>Multiple interpretations:</dt>
<dd>writing a DSL program once, and interpret it many times, in standard and non-standard ways;</dd>
<dt>Extensibility:</dt>
<dd>enriching the syntax of the object language, re-using but not breaking the existing interpreters;</dd>
<dt><em>Types</em></dt>
<dd><dl><dt>Typed implementation language</dt>
<dd>getting the typechecker to verify properties of interpreters, such as not getting stuck;</dd>
<dt>Typed object language</dt>
<dd>getting the metalanguage typechecker to enforce properties of DSL programs, such as being well-typed;</dd>
<dt>Connections with logic</dt></dl></dd>
<dt>Final</dt>
<dd><dl><dt>preferring lower-case</dt>
<dt>preferring elimination over introduction</dt>
<dt>connecting to denotational semantics</dt></dl></dd></dl></dd></dl>
<p><a name="lecture">&nbsp;</a></p><h2>Lecture Notes</h2>
<dl><dd>[The Abstract of the paper]
<br>

The so-called `typed tagless final' approach of
Carette et al. has collected and polished a number of
techniques for representing typed higher-order languages in a typed
metalanguage, along with type-preserving interpretation, compilation
and partial evaluation.  The approach is an alternative to the
traditional, or `initial' encoding of an object language as a
(generalized) algebraic data type. Both approaches permit multiple
interpretations of an expression, to evaluate it, pretty-print,
etc. The final encoding represents all and only typed object terms
without resorting to generalized algebraic data types, dependent or
other fancy types. The final encoding lets us add new language forms
and interpretations without breaking the existing terms and interpreters.<p>
These lecture notes introduce the final approach slowly and in detail,
highlighting extensibility, the solution to the expression problem, and the
seemingly impossible pattern-matching. We develop the approach
further, to type-safe cast, run-time-type representation, Dynamics, and
type reconstruction. We finish with telling examples of type-directed
partial evaluation and encodings of type-and-effect systems and
linear lambda-calculus.</p></dd>
<dt><strong>Version</strong></dt>
<dd>The current version is August 2012.</dd>
<dt><strong>References</strong></dt>
<dd><a href="lecture.pdf">lecture.pdf</a> [275K]
<br>
Typed Tagless Final Interpreters
<br>
<cite>Generic and Indexed Programming:</cite> International Spring School, SSGIP 2010, Oxford, UK, March 22-26, 2010, Revised Lectures
<br>
Springer-Verlag Berlin Heidelberg, Lecture Notes in Computer Science 7470, 2012, pp. 130-174 <a href="http://dx.doi.org/10.1007/978-3-642-32202-0_3">doi:10.1007/978-3-642-32202-0_3</a></dd></dl><h1>First-order languages (generic programming)</h1>
<p>We will be talking about ordinary data types and (generic) operations on them. The expression problem will make its appearance. The first-order case makes it easier to introduce de-serialization and seemingly non-compositional operations.</p>
<p><a name="infin1">&nbsp;</a></p><h2>Initial and final, deep and shallow: the first-order case</h2>
<dl><dd><a href="Intro1.hs">Intro1.hs</a> [2K]
<br>
Algebraic data type/initial representation of expressions
<br>
Constructor functions: the intimation of the final representation (or, shallow embedding)<p><a href="Intro2.hs">Intro2.hs</a> [3K]
<br>
Symantics: parameterization of terms by interpreters</p>
<p><a href="Intro3.hs">Intro3.hs</a> [2K]
<br>
Initial and Final, Deep and Shallow, First-class</p>
<p><a href="ExtI.hs">ExtI.hs</a> [&lt;1K]
<br>
Algebraic data types are indeed not extensible</p>
<p><a href="ExtF.hs">ExtF.hs</a> [2K]
<br>
Adding a new expression form to the final view: solving the expression problem</p>
<p><a href="Serialize.hs">Serialize.hs</a> [7K]
<br>
Serialization and de-serialization</p>
<p><a href="SerializeExt.hs">SerializeExt.hs</a> [4K]
<br>
De-serializing the extended language</p></dd></dl>
<p><a name="fin-OCaml">&nbsp;</a></p><h2>Final embeddings in OCaml</h2>
<dl><dd>We demonstrate several encodings of extensible first-order languages in OCaml. Objects turn out handy in emulating the composition of type class dictionaries.<p><a href="final_obj.ml">final_obj.ml</a> [2K]
<br>
The traditional application of objects to represent extensible data types. Alas, the set of operations on these data types is not extensible.</p>
<p><a href="final_mod.ml">final_mod.ml</a> [3K]
<br>
Tagless-final embedding using modules</p>
<p><a href="final_dic.ml">final_dic.ml</a> [3K]
<br>
Tagless-final embedding with objects emulating type-class dictionaries. Both the language and the set of its interpretations are extensible.</p></dd></dl>
<p><a name="non'compositionality">&nbsp;</a></p><h2>Non-compositionality: Fold-<em>unlike</em> processing</h2>
<dl><dd>Interpreters are well suited for compositional, fold-like operations on terms. The tagless-final representation of terms makes writing interpreters quite convenient. One may wonder about operations on terms that do not look like fold. Can we even pattern-match on terms represented in the tagless-final style? Can we compare such terms for equality? We answer the first question here, deferring the equality test till the part on implementing a type checker for a higher-order language. Our running examples are term transformations, converting an expression into a simpler, more optimal, or canonical form. The result is an uncrippled expression, which we can feed into any of the existing or future interpreters. Our sample term transformations look like simplified versions of the conversion of a boolean formula into a conjunctive normal form.<p><a href="PushNegI.hs">PushNegI.hs</a> [3K]
<br>
Pushing the negation down: the initial implementation</p>
<p><a href="PushNegF.hs">PushNegF.hs</a> [3K]
<br>
Pushing the negation down: the final implementation</p>
<p><a href="PushNegFExt.hs">PushNegFExt.hs</a> [4K]
<br>
Pushing the negation down for extended tagless-final terms</p>
<p><a href="FlatI.hs">FlatI.hs</a> [2K]
<br>
<a href="FlatF.hs">FlatF.hs</a> [4K]
<br>
Flattening of additions, the initial and the final implementations</p>
<p><a href="PushNegFI.hs">PushNegFI.hs</a> [4K]
<br>
The final-initial isomorphism, and its use for implementing arbitrary pattern-matching operations on tagless-final terms.
<br>
<a href="http://www.comlab.ox.ac.uk/ralf.hinze/SSGIP10/Slides.pdf">&lt; http://www.comlab.ox.ac.uk/ralf.hinze/SSGIP10/Slides.pdf &gt;</a>
<br>
Ralf Hinze, in Part 7 of his Spring School course, has derived this `initial-final' isomorphism rigorously, generally and elegantly from the point of view of Category Theory. In the first-order case, both `initial' and `final' are the left and the right views to the same Initial Algebra. The `final' view is, in the first-order case, ordinary Church encoding.</p></dd></dl><h1>Interpreters for higher-order languages</h1>
<p>Higher-order languages are data types with binding, so to speak. In the first part, only the interpreters were typed; we could get away with our object language being unityped. Now, the object language itself becomes typed, bringing the interesting issues of interpreting a typed language in a type language ensuring type preservation. It is this part that explains the attributes `typed' and 'tagless' in the title of the course.</p>
<p><a name="HO">&nbsp;</a></p><h2>Type-preserving embedding of higher-order, typed DSLs</h2>
<dl><dd>Using simply-typed lambda-calculus with constants as a sample DSL, we demonstrate its various embeddings into Haskell. We aim at a type-preserving embedding and efficient and type-preserving evaluations. The tagless-final embedding not only achieves this goal, it also makes the type-preservation patently clear. Tagless-final evaluators are well-typed Haskell programs with no pattern-matching on variant types. It becomes impossible for the evaluators to get stuck. Since the type preservation of the evaluators is apparent not only to us but also to a Haskell compiler, the evaluators can be efficiently compiled. Tagless-final embeddings are also extensible, letting us add to the syntax of the DSL, preserving and reusing old interpreters.<p><a href="IntroHOT.hs">IntroHOT.hs</a> [3K]
<br>
The illustration of problems of embedding a typed DSL into a typed metalanguage
<br>
Either the Universal type (and hence spurious partiality, type tags and inefficiency), or fancy type systems seem inevitable. The problem stems from algebraic data types' being too broad: they express not only well-typed DSL terms but also ill-typed ones.</p>
<p><a href="Term.agda">Term.agda</a> [2K]
<br>
<a href="http://www.iis.sinica.edu.tw/~scm/2008/typed-lambda-calculus-interprete/">&lt; http://www.iis.sinica.edu.tw/~scm/2008/typed-lambda-calculus-interprete/ &gt;</a>
<br>
Shin-Cheng Mu: Typed Lambda-Calculus Interpreter in Agda. September 24, 2008
<br>
Shin-Cheng Mu solves the problem of the type-preserving tagless interpretation of simply-typed lambda-calculus, relying on dependent types and type functions in full glory.</p>
<p><a href="IntroHOIF.hs">IntroHOIF.hs</a> [6K]
<br>
Tagless-initial and Tagless-final evaluators</p>
<p><a href="TTFdB.hs">TTFdB.hs</a> [7K]
<br>
Typed, tagless, final, with de Bruijn indices: Expressing the type system of simply-typed lambda-calculus in Haskell98. No dependent types are necessary after all. The types of methods in the Symantics type class read like the axioms and inference rules of the implication fragment of minimal logic.</p>
<p><a href="TTF.hs">TTF.hs</a> [7K]
<br>
Typed, tagless, final, in the higher order abstract syntax (HOAS). We illustrate extending the DSL with more constants, types, and expression forms.</p>
<p><a href="TTIF.hs">TTIF.hs</a> [8K]
<br>
Initial-final isomorphism, in the higher-order case</p></dd></dl>
<p><a name="type-checking">&nbsp;</a></p><h2>De-serialization and type-checking</h2>
<dl><dd>Since we represent DSL expressions as well-typed Haskell terms, we can place DSL terms in Haskell code or enter at the GHCi prompt. However, we also want to interpret DSL expressions that are read from files or received from communication pipes. We no longer can then rely on GHC to convert DSL expressions from a text format into the typed embedding. We have to do the type-checking of DSL expressions ourselves. Our goal is to type-check an expression once, during de-serialization, and evaluate the result many times. Since a type checker needs to represent types and reason about type equality, we develop type representations and type safe cast. We regard the language of types, too, as a typed DSL, which we embed in Haskell in the tagless-final style.<p><a href="TypeCheck.hs">TypeCheck.hs</a> [12K]
<br>
De-serialization: (Dynamic) Type Checking
<br>
In contrast to an earlier version of the type checker, we use de Bruijn indices and obtain a much clearer code. The code is quite similar to Baars and Swierstra's ``Typing Dynamic Typing'' (ICFP02). However, the result of our type-checking is an embedded DSL expression that can be interpreted many times and in many ways, rather than being merely evaluated. The set of possible interpretations is open. Also, our code is written to expose more properties of the type-checker for verification by the Haskell type-checker; for example, that closed source terms are de-serialized into closed target terms.</p>
<p><a href="Typ.hs">Typ.hs</a> [8K]
<br>
Type representation, equality and the type-safe generalized cast
<br>
We present an above-the-board version of <code>Data.Typeable</code> , in the tagless-final style. Our implementation uses no GHC internal operations, no questionable extensions, or even a hint of unsafe operations.</p>
<p><a href="http://www.comlab.ox.ac.uk/projects/gip/school/tc.hs">&lt; http://www.comlab.ox.ac.uk/projects/gip/school/tc.hs &gt;</a>
<br>
Stephanie Weirich some time ago wrote a very similar type-checker, but in the initial style, using GADTs. The comparison with the tagless-final style here is illuminating.</p></dd></dl><h1>Applications and Extensions</h1>
<p><a name="CPS">&nbsp;</a></p><h2>Ordinary and one-pass CPS transformation</h2>
<dl><dd>We demonstrate ordinary and administrative-redex--less call-by-value Continuation Passing Style (CPS) transformation that assuredly produces well-typed terms and is <em>patently</em> total.<p>Our goal here is not to evaluate, view or serialize a tagless-final term, but to transform it to another one. The result is a tagless-final term, which we can interpret in multiple ways: evaluate, view, or transform again. We first came across transformations of tagless-final terms when we discussed pushing the negation down in the simple, unityped language of addition and negation. The general case is more complex. It is natural to require the result of transforming a well-typed term be well-typed. In the tagless-final approach that requirement is satisfied automatically: after all, only well-typed terms are expressible. We impose a more stringent requirement that a transformation be total.  In particular, the fact that the transformation handles all possible cases of the source terms must be patently, syntactically clear. The complete coverage must be so clear that the metalanguage compiler should be able to see that, without the aid of extra tools.</p>
<p>Since the only thing we can do with tagless-final terms is to interpret them, the CPS transformer is written in the form of an interpreter. It interprets source terms yielding transformed terms, which can be interpreted in many ways. In particular, the terms can be interpreted by the CPS transformer again, yielding 2-CPS terms. CPS transformers are composable, as expected.</p>
<p>A particular complication of the CPS transform is that the type of the result is different from the type of the source term: the CPS transform translates not only terms but also types. Moreover, the CPS type transform and the arrow type constructor do not commute. For that reason, we have to introduce an extended Symantics class, ESymantics, which makes the meaning of function types dependent on a particular interpreter. As it turns out, we do not have to re-write the existing Symantics terms: we can re-interpret any old terms in the extended Symantics. Conversely, any extended Symantics term can be interpreted using any old, legacy, Symantics interpreter. The CPS transform is an extended Symantics interpreter proper.</p>
<p>The ordinary (Fischer or Plotkin) CPS transform introduces many administrative redices, which make the result too hard to read. Danvy and Filinski proposed a one-pass CPS transform, which relies on the metalanguage to get rid of the administrative redices. The one-pass CPS transform can be regarded as an example of the normalization-by-evaluation.</p>
<p><a href="CPS.hs">CPS.hs</a> [12K]
<br>
Ordinary and one-pass CPS transforms and their compositions</p>
<p>Olivier Danvy and Andrzej Filinski. Representing Control: A Study of the CPS Transformation.
<br>
Mathematical Structures in Computer Science, 1992.</p></dd></dl>
<p><a name="TDPE">&nbsp;</a></p><h2>Type-directed partial evaluation</h2>
<dl><dd>Olivier Danvy's original POPL96 paper on type-directed partial evaluation used an untyped target language, represented as an algebraic data type. Type preservation was not apparent and had to be proved. In our presentation, the result of reification is a <em>typed</em> expression, in the tagless-final form. Type preservation of reification is now syntactically apparent and is verified by the Haskell type-checker. In the tagless-final presentation, reification and reflection seem particularly symmetric, elegant and insightful.<p><a href="TDPE.hs">TDPE.hs</a> [6K]
<br>
Tagless-final presentation of type-directed partial evaluation
<br>
<a href="ToTDPE.hs">ToTDPE.hs</a> [&lt;1K]
<br>
The imported module with sample functions to reify. Compiling this module makes for a nicer example.</p>
<p><a href="http://www.brics.dk/~danvy/tdpe-ln.pdf">&lt; http://www.brics.dk/~danvy/tdpe-ln.pdf &gt;</a>
<br>
Olivier Danvy: Lecture notes on type-directed partial evaluation. The lecture notes are based on his POPL96 paper.</p></dd></dl>
<p><a name="linear">&nbsp;</a></p><h2>Linear and affine lambda-calculi</h2>
<dl><dd>
One may think that only those DSL can be embedded in Haskell whose
type system is a subset of that of Haskell. To counter that impression
we show how to faithfully embed typed <em>linear</em> lambda calculus. Any
bound variable must be referenced exactly once in abstraction's
body. As before, only well-typed and well-formed terms are
representable. Haskell as the metalanguage will statically reject as
ill-typed the attempts to represent terms with a bound variable
referenced several times -- or, as in the K combinator, never.<p>We build on the embedding of the ordinary simply typed lambda calculus with de Bruijn indices described earlier. An object term of the type <code>a</code> was represented as a value of the type <code>repr h a</code> where the binary type constructor <code>repr</code> is a member of the class <code>Symantics</code> . Here <code>h</code> stands for the type environment, assigning types to free variables (`hypotheses') of a term. Linear lambda calculus regards bound variables as representing resources; referencing a variable consumes the resource. We use the type environment for tracking the state of resources: available or consumed. The type environment becomes the type <em>state</em> . We follow the approach described in <a href="../../Computation/monads.html#param-monad">Variable (type)state `monad'</a> .</p>
<p>We represent linear lambda terms by Haskell values of the type <code>repr hi ho a</code> , where <code>hi</code> stands for the variable state before evaluating the term and <code>ho</code> stands for the state after evaluating the term. To be more precise, <code>hi</code> and <code>ho</code> are the types of the variable states. We can determine the types and hence the state of the variables statically: As usual, the type checker does abstract interpretation. In our tagless-final encoding, <code>lam</code> has the following type</p>
<pre>     	 lam :: repr (F a,hi) (U,ho) b  -&gt; repr hi ho (a-&gt;b)
</pre>The expression <code>(lam e)</code> has the type <code>repr hi ho (a-&gt;b)</code> provided the body of abstraction, <code>e</code> , has the type <code>repr (F a,hi) (U,ho) b</code> . That is, in the environment extended with a term of the type <code>a</code> , the body must produce the value of type <code>b</code> . The body must consume the term at the top of the environment, changing the type of the first environment cell from <code>F a</code> to <code>U</code> (the type of the used variable).<p>A trivial modification turns the embedding of the linear lambda-calculus into that of the affine lambda-calculus, which allows to ignore bound variables. K combinator becomes expressible.</p>
<p><a href="LinearLC.hs">LinearLC.hs</a> [11K]
<br>
Commented code defining the typed linear lambda calculus and its two interpreters, to evaluate and to show linear lambda terms. Later we add general abstractions imposing no constraints on the use of bound variables.</p>
<p>Jeff Polakow: typed final-tagless HOAS interpreter for linear lambda calculus
<br>
Message posted on Haskell-Cafe on March 26, 2013.
<br>
<a href="http://www.haskell.org/pipermail/haskell-cafe/2013-March/107215.html">&lt; http://www.haskell.org/pipermail/haskell-cafe/2013-March/107215.html &gt;</a>
<br>

 Polakow's tagless-final linear lambda-calculus interpreter
 relies on higher-order abstract syntax, rather than de Bruijn
 indices of LinearLC.hs. The interpreter explained in the posted message
 has only arrow types and integers. Attached to that message is the
 interpreter for the full linear lambda calculus with additives and units.</p></dd></dl>
<p><a name="misc">&nbsp;</a></p><h2>Further applications</h2>
<dl><dd><ul><li><a href="CBAny.hs">CBAny.hs</a> [6K]
<br>
Parameterizing evaluators by the evaluation order: call-by-name, call-by-value, call-by-need
<br>
<a href="../CB98.hs">CB98.hs</a> [7K]
<br>
The same, but in pure Haskell 98</li>
<li><a href="PrintScanF.hs">PrintScanF.hs</a> [8K]
<br>
Typed formatting: printf and scanf. The code is one of the implementations of <a href="../../typed-formatting/">Type-safe Formatted IO</a> .</li>
<li>Sandro Magi: Mobile Code in C# via Finally Tagless Interpreters. June 23, 2009.
<br>
<a href="http://higherlogics.blogspot.com/2009/06/mobile-code-in-c-via-finally-tagless.html">&lt; http://higherlogics.blogspot.com/2009/06/mobile-code-in-c-via-finally-tagless.html &gt;</a>
<br>
Sandro Magi shows that different interpretations of the same DSL term may not only involve different run-time systems but also occur on different hosts.</li>
<li><a href="../sharing/index.html">Expressing sharing</a></li>
<li>Non-standard and abstract interpretations</li>
<li>Unusual calculi: shift/reset with effect typing; lambda-mu-mubar</li>
<li>Abstract Categorial Grammars
<br>
<a href="http://www.loria.fr/equipes/calligramme/acg">&lt; http://www.loria.fr/equipes/calligramme/acg &gt;</a></li></ul></dd></dl>
<br>
<div><hr></div><h3>Last updated April 7, 2013</h3>
This site's top page is <a href="http://kinokkory.github.io/okmij/"><strong>http://kinokkory.github.io/okmij/</strong></a><div><p><cite>oleg-at-pobox.com or oleg-at-okmij.org</cite>
<br>
Your comments, problem reports, questions are very welcome!</p></div>
<p><font size="-2">Converted from HSXML by HSXML-&gt;HTML</font></p></body></html>
