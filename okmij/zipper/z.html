<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Zipper1.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
From oleg-at-okmij.org Wed Apr 27 16:17:04 2005
To: haskell@haskell.org
Subject: Zipper as a delimited continuation
X-comment: Aug 26, 2009: implemented a different convention for the
  direction of traversal steps. It is less convenient but more
  intuitive since it takes one step to reach a parent of a subterm. The
  addendum was prompted by a conversation with Ron de Bruijn, who
  pointed out that the traversal directions in the original `traverse'
  are unintuitive. In particular, it takes more than one Up step to
  really reach a parent of a subterm.
X-comment: Feb 2011: Switching to the delimcc library
Message-ID: <20050427231704.DE8F9ABCC@Adric.metnet.navy.mil>
Date: Wed, 27 Apr 2005 16:17:04 -0700 (PDT)
Status: OR


This is the first part of a reply to a query about a zipper with two
foci, posted on this list by Oktaviandi Hadi Nugraha on Apr 13. In
this part we introduce the framework to answer the question.

Our treatment of zipper is quite different from that of Huet (JFP,
1997) and Hinze and Jeuring (JFP 2001). Our zipper is polymorphic over
the data structure to traverse, and the zipper creation procedure is
generic and does not depend on the data structure at all.  Different
data structures or different realizations of the same abstract data
structure can use the same zipper and the same zipper creation and
manipulation functions. Our zipper type depends only on the interface
(but not the implementation!) of a traversal function. Our zipper is a
derivative of a traversal function rather than that of a data
structure itself.

Zipper is a construction that lets us replace an item deep in a
complex data structure, e.g., a tree or a term, without any
mutation. The resulting data structure will share as much of its
components with the old structure as possible. The old data structure
is still available (which can be handy if we wish to 'undo' the
operation later on). Zipper is essentially an `updateable' and yet
pure functional cursor into a data structure.

Zipper is also a delimited continuation reified as a data
structure. In this message, we use delimited continuations directly to
derive the zipper. We will be relying on the delimited continuation
library delimcc, which permits single and multiple prompts.

<pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- Haskell98!</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Zipper1</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- Import delimcc, see</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- <a href="http://okmij.org/ftp/continuations/implementations.html#CC-monads">http://okmij.org/ftp/continuations/implementations.html#CC-monads</a></span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>CCExc</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- import CCCxce  -- would work as well</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Identity</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span>
</pre>

The derivation of the zipper starts with a term traversal function. The
zipper will be as good and powerful as the traversal function. Let us
adopt as a running example the familiar and dear data structure:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Term</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>A</span> <span class='hs-conid'>Term</span> <span class='hs-conid'>Term</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>L</span> <span class='hs-conid'>String</span> <span class='hs-conid'>Term</span> 
<span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>Term</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>show</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showt</span> <span class='hs-num'>0</span> <span class='hs-varid'>term</span> 
<span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>where</span> <span class='hs-varid'>showt</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s</span>
<span class='hs-varop'>&gt;</span>          <span class='hs-varid'>showt</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>paren</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>10</span><span class='hs-layout'>)</span> 
<span class='hs-varop'>&gt;</span>                               <span class='hs-layout'>(</span><span class='hs-varid'>showt</span> <span class='hs-num'>10</span> <span class='hs-varid'>e1</span> <span class='hs-varop'>++</span> <span class='hs-str'>" "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showt</span> <span class='hs-num'>11</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>          <span class='hs-varid'>showt</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>v</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>paren</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-str'>"L"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>v</span> <span class='hs-varop'>++</span> <span class='hs-str'>". "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showt</span> <span class='hs-num'>0</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>          <span class='hs-varid'>paren</span> <span class='hs-conid'>True</span>  <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"("</span> <span class='hs-varop'>++</span> <span class='hs-varid'>s</span> <span class='hs-varop'>++</span> <span class='hs-str'>")"</span>
<span class='hs-varop'>&gt;</span>          <span class='hs-varid'>paren</span> <span class='hs-conid'>False</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s</span>
</pre>

In this message, we chose the following function to traverse the lambda-term:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Direction</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Down</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DownRight</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Up</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Next</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>traverse</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Term</span><span class='hs-layout'>,</span> <span class='hs-conid'>Direction</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>Term</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varid'>term'</span><span class='hs-layout'>,</span> <span class='hs-varid'>direction</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>let</span> <span class='hs-varid'>new_term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybe</span> <span class='hs-varid'>term</span> <span class='hs-varid'>id</span> <span class='hs-varid'>term'</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>let</span> <span class='hs-varid'>select</span> <span class='hs-conid'>Up</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>t</span>
<span class='hs-varop'>&gt;</span>       <span class='hs-varid'>select</span> <span class='hs-conid'>Next</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>t</span>
<span class='hs-varop'>&gt;</span>       <span class='hs-varid'>select</span> <span class='hs-varid'>dir</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dir</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Next</span> <span class='hs-varop'>||</span> <span class='hs-varid'>dir</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Down</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   	  <span class='hs-varid'>t1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>t1</span>
<span class='hs-varop'>&gt;</span>   	  <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>L</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t1'</span>
<span class='hs-varop'>&gt;</span>       <span class='hs-varid'>select</span> <span class='hs-conid'>DownRight</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   	  <span class='hs-varid'>t2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>t2</span>
<span class='hs-varop'>&gt;</span>   	  <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>A</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2'</span>
<span class='hs-varop'>&gt;</span>       <span class='hs-varid'>select</span> <span class='hs-varid'>dir</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dir</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Next</span> <span class='hs-varop'>||</span> <span class='hs-varid'>dir</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Down</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   	  <span class='hs-varid'>t1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>t1</span>
<span class='hs-varop'>&gt;</span>   	  <span class='hs-varid'>t2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>t2</span>
<span class='hs-varop'>&gt;</span>   	  <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>A</span> <span class='hs-varid'>t1'</span> <span class='hs-varid'>t2'</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>select</span> <span class='hs-varid'>direction</span> <span class='hs-varid'>new_term</span>
</pre>
The function `traverse' receives the traversal function `tf' and the
lambda-term, and walks and _updates_ the term, as guided by `tf'.  The
traversal function receives the current subterm and should return a
pair. If the first component of a pair is (Just t'), then t' replaces
the current subterm. The second component of tf's result is the
direction to proceed. The direction Next means proceed in the
depth-first order. Other directions may be used to skip some parts of
the term and so avoid walking the whole term. The function is written
in a monadic style (for an arbitrary monad m). We shall need that
later.

[Addendum] 
I guess I should have used better names for Up, Down, etc. For
example, one can see from the code for 'traverse' that Up means we
are done with the term, and Next and Down are almost synonymous. To
move to the parent of a subterm, we almost always have to make two
steps Up. I guess I visualized the direction not by the destination
point but by the source point: where to go from the current term:
traverse its children or not. At the end of the file, we show
a different choice of step directions.
[/Addendum]


We will be using the following term as a running example:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- P2 numeral</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>term1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>L</span> <span class='hs-str'>"f"</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"x"</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"f"</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"f"</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"x"</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> 			  <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"f"</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"x"</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>  <span class='hs-keyword'>where</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"f"</span><span class='hs-layout'>,</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span>
</pre>
The first test simply traverses the whole term, makes no alterations
and returns the (copy of the) term:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>testt1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runIdentity</span> <span class='hs-layout'>(</span><span class='hs-varid'>traverse</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-conid'>Next</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>term1</span><span class='hs-layout'>)</span>
</pre>
-- *Zipper1> testt1 == term1
-- True

To make sure that we really traverse the term, we can print out all
the encountered subterms:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>testt2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term1</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>where</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>print</span> <span class='hs-varid'>term</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-conid'>Next</span><span class='hs-layout'>)</span>
</pre>

We instantiate `traverse' for the IO monad this time. We can skip some
parts of the term during the traversal:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>testt3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term1</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>where</span> 
<span class='hs-varop'>&gt;</span>     <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-str'>"f"</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span> 			         <span class='hs-varid'>print</span> <span class='hs-str'>"cutting"</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>print</span> <span class='hs-varid'>term</span>
<span class='hs-varop'>&gt;</span> 			         <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-conid'>Up</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>print</span> <span class='hs-varid'>term</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-conid'>Next</span><span class='hs-layout'>)</span>
</pre>
and we can modify the term

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>testt4</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runIdentity</span> <span class='hs-layout'>(</span><span class='hs-varid'>traverse</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term1</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>where</span> <span class='hs-varid'>tf</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"x"</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-str'>"x"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"y"</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-str'>"y"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-conid'>Next</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> 	    <span class='hs-varid'>tf</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-conid'>Next</span><span class='hs-layout'>)</span>
</pre>
which indeed returns term1 with all occurrences of (L "x" (Var "x"))
replaced with (L "y" (Var "y")).


Now we an introduce the zipper:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Zipper</span> <span class='hs-varid'>m</span> <span class='hs-varid'>term</span> <span class='hs-varid'>dir</span> <span class='hs-keyglyph'>=</span> 
<span class='hs-varop'>&gt;</span>     <span class='hs-conid'>Zipper</span> <span class='hs-varid'>term</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>term</span><span class='hs-layout'>,</span> <span class='hs-varid'>dir</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CCW</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>m</span> <span class='hs-varid'>term</span> <span class='hs-varid'>dir</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ZipDone</span> <span class='hs-varid'>term</span>
</pre>
The traversal monad is the CC delimcc transformer applied to the base
monad "m".  We will be using the prompt flavor PS. There is only one
prompt of this flavor, bound to the global variable |ps|, for the
fixed answer-type Zipper m term dir (the answer-type is recursive).

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>CCM</span> <span class='hs-varid'>m</span> <span class='hs-varid'>term</span> <span class='hs-varid'>dir</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CC</span> <span class='hs-layout'>(</span><span class='hs-conid'>PS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>m</span> <span class='hs-varid'>term</span> <span class='hs-varid'>dir</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> 
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>CCW</span> <span class='hs-varid'>m</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CC</span> <span class='hs-layout'>(</span><span class='hs-conid'>PS</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span> <span class='hs-varid'>m</span> <span class='hs-varid'>w</span>
</pre>
Zipper is indeed polymorphic over the term to traverse (as well over the
source monad 'm'). We can use this Zipper, as it is, for _any_ data
structure that can be traversed by a function that looks like
`traverse'. 

Creating the zipper equally generic:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'term</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CCM</span> <span class='hs-varid'>m</span> <span class='hs-varid'>term</span> <span class='hs-varid'>dir</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>term</span><span class='hs-layout'>,</span> <span class='hs-varid'>dir</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CCM</span> <span class='hs-varid'>m</span> <span class='hs-varid'>term</span> <span class='hs-varid'>dir</span> <span class='hs-varid'>term</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CCW</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>m</span> <span class='hs-varid'>term</span> <span class='hs-varid'>dir</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'term</span> <span class='hs-varid'>trav</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pushPrompt</span> <span class='hs-varid'>ps</span> <span class='hs-layout'>(</span><span class='hs-varid'>trav</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-conid'>ZipDone</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>where</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>shift0P</span> <span class='hs-varid'>ps</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>k</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>term</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
Both Zipper and its creation function depend neither on the
representation of the term nor on the traversal strategy.  All the
information about the data structure and its traversal is
encapsulated in one single function `trav'.

We can now examine term1, subterm by subterm, using the cursor,
zipper, rather than the enumerator, traverse:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'through</span> <span class='hs-layout'>(</span><span class='hs-conid'>ZipDone</span> <span class='hs-varid'>term</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>print</span> <span class='hs-str'>"Done"</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>print</span> <span class='hs-varid'>term</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'through</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>term</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>print</span> <span class='hs-varid'>term</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-conid'>Next</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>zip'through</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>tz1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>tz1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runCC</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zip'term</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>term1</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>zip'through</span>
</pre>
We have effectively `inverted' the operation of term traversal. With
the cursor, we can keep the arbitrary state from one traversal step to
another.

The cursor provided by zipper is updateable. We can now descend (or
walk) to the desired node, replace it, and zip up the result to yield
the updated term:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'move</span> <span class='hs-varid'>dir</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>term</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> 
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>liftIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>print</span> <span class='hs-varid'>dir</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>print</span> <span class='hs-varid'>term</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-varid'>dir</span><span class='hs-layout'>)</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'upr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>term</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-varid'>nt</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> 
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>liftIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>print</span> <span class='hs-varid'>term</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>print</span> <span class='hs-str'>"replacing with"</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>print</span> <span class='hs-varid'>nt</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>nt</span><span class='hs-layout'>,</span><span class='hs-conid'>Up</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'all'the'way'up</span> <span class='hs-layout'>(</span><span class='hs-conid'>ZipDone</span> <span class='hs-varid'>term</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>term</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>zip'all'the'way'up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>term</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> 
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-conid'>Up</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>zip'all'the'way'up</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>tz2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span> 
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>tz2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runCC</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'term</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>term1</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>Next</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>Next</span> <span class='hs-varid'>z1</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>DownRight</span> <span class='hs-varid'>z1</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>res</span> <span class='hs-keyglyph'>&lt;-</span>  <span class='hs-varid'>zip'upr</span> <span class='hs-varid'>z2</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-str'>"x"</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-str'>"x"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>zip'all'the'way'up</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>print</span> <span class='hs-str'>"Result"</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>print</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>--zip'through z1</span>
</pre>
*Zipper1> tz2
Next
Lf. Lx. f (Lf. f (Lf. Lx. x)) (f (Lf. Lx. x) x)
Next
Lx. f (Lf. f (Lf. Lx. x)) (f (Lf. Lx. x) x)
DownRight
f (Lf. f (Lf. Lx. x)) (f (Lf. Lx. x) x)
f (Lf. Lx. x) x
"replacing with"
x x
"Result"
Lf. Lx. f (Lf. f (Lf. Lx. x)) (x x)

We obtain an arbitrary number of cursors over the same data structure:
for example, in `tz2', the cursor 'z1' is still valid at the end, and
still points out to the `third' subterm. The cursor 'z2' is valid as
well. All these cursors are isolated: the updates done with the cursor
'z2' are invisible to the cursor 'z1' (as we can see if we uncomment
the last statement in tz2). Essentially, each cursor runs in its own
transaction. In the second part we will discuss how to make cursors
that see the updates of each other. Contrary to the traditional
database wisdom, for zippers, it is far harder to implement lower
isolation modes than the higher ones.


[Addendum]
We now implement a different convention for traversal steps:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Direction1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FirstKid</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RightKid</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Parent</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
</pre>
Now it takes one step, Parent, to reach a parent of a subterm. We also
clarified the names of the steps to reach the first child or the last
child of a composite term.


<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>traverse1</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> 
<span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-conid'>Term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Term</span><span class='hs-layout'>,</span> <span class='hs-conid'>Direction1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>Term</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>traverse1</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span> <span class='hs-varid'>term</span>
<span class='hs-varop'>&gt;</span>  <span class='hs-keyword'>where</span> 
<span class='hs-varop'>&gt;</span>  <span class='hs-varid'>loop</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span> 	<span class='hs-layout'>(</span><span class='hs-varid'>term'</span><span class='hs-layout'>,</span> <span class='hs-varid'>direction</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tf</span> <span class='hs-varid'>term</span>
<span class='hs-varop'>&gt;</span> 	<span class='hs-keyword'>let</span> <span class='hs-varid'>new_term</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybe</span> <span class='hs-varid'>term</span> <span class='hs-varid'>id</span> <span class='hs-varid'>term'</span>
<span class='hs-varop'>&gt;</span> 	<span class='hs-keyword'>let</span> <span class='hs-varid'>select</span> <span class='hs-conid'>Parent</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>t</span>
<span class='hs-varop'>&gt;</span> 	    <span class='hs-varid'>select</span> <span class='hs-varid'>dir</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dir</span> <span class='hs-varop'>==</span> <span class='hs-conid'>FirstKid</span> <span class='hs-varop'>||</span> <span class='hs-varid'>dir</span> <span class='hs-varop'>==</span> <span class='hs-conid'>RightKid</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span> 	       <span class='hs-varid'>t1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>loop</span> <span class='hs-varid'>t1</span>
<span class='hs-varop'>&gt;</span> 	       <span class='hs-varid'>loop</span> <span class='hs-varop'>$</span> <span class='hs-conid'>L</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t1'</span>
<span class='hs-varop'>&gt;</span> 	    <span class='hs-varid'>select</span> <span class='hs-conid'>RightKid</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span> 	       <span class='hs-varid'>t2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>loop</span> <span class='hs-varid'>t2</span>
<span class='hs-varop'>&gt;</span> 	       <span class='hs-varid'>loop</span> <span class='hs-varop'>$</span> <span class='hs-conid'>A</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2'</span>
<span class='hs-varop'>&gt;</span> 	    <span class='hs-varid'>select</span> <span class='hs-conid'>FirstKid</span> <span class='hs-varid'>t</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span> 	       <span class='hs-varid'>t1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>loop</span> <span class='hs-varid'>t1</span>
<span class='hs-varop'>&gt;</span> 	       <span class='hs-varid'>loop</span> <span class='hs-varop'>$</span> <span class='hs-conid'>A</span> <span class='hs-varid'>t1'</span> <span class='hs-varid'>t2</span>
<span class='hs-varop'>&gt;</span> 	<span class='hs-varid'>select</span> <span class='hs-varid'>direction</span> <span class='hs-varid'>new_term</span>
</pre>
The zipper functions remain exactly as they are. The following example
illustrates the full traversal of a sample term
    (L "x" (A (Var "a") (Var "b")))

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tz3</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span> 
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>tz3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runCC</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'term</span> <span class='hs-varid'>traverse1</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-str'>"x"</span> <span class='hs-layout'>(</span><span class='hs-conid'>A</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>FirstKid</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>FirstKid</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>Parent</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>RightKid</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>Parent</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>z</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>Parent</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-conid'>ZipDone</span> <span class='hs-varid'>term</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip'move</span> <span class='hs-conid'>Parent</span> <span class='hs-varid'>z</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>print</span> <span class='hs-str'>"Done:"</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>print</span> <span class='hs-varid'>term</span>
</pre>
FirstKid
Lx. a b
FirstKid
a b
Parent
a
RightKid
a b
Parent
b
Parent
a b
Parent
Lx. a b
"Done:"
Lx. a b

The new traverse1 may be more intuitive but less convenient: there are
no Next step.

</body>
</html>
